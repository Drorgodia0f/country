{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE OverloadedStrings #-}

import Streaming (Stream,Of(..))
import Siphon (Siphon)
import Colonnade (Headed)
import Data.ByteString (ByteString)
import Data.Text (Text)
import System.IO
import Data.Text.Encoding (encodeUtf8,decodeUtf8')
import Data.Char (isAlpha,toLower)
import qualified Streaming as SM
import qualified Streaming.Prelude as SMP
import qualified Siphon as S
import qualified Data.Text as T
import qualified Data.Text.Lazy as LT
import qualified Data.Text.Lazy.Builder as TB
import qualified Data.Text.Lazy.Builder.Int as TBI
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Streaming as BSM

main :: IO ()
main = do
  withCountries "country/src/Country/Unexposed/Encode/English.hs" englishEncoding
  withCountries "country/src/Country/Identifier.hs" identifierModule
  withCountries "country/src/Country/Unexposed/Enumerate.hs" enumerateModule
  -- withCountries "country/src/Country/Unexposed/AlphaCode.hs" alphaCodeModule

enumerateModule :: Monad m => Stream (Of Country) m r -> Stream (Of Text) m r
enumerateModule s = do
  SMP.yield "module Country.Unexposed.Enumerate where\n\n"
  SMP.yield "-- This module is autogenerated. Do not edit it by hand.\n\n"
  SMP.yield "import Data.Word (Word16)\n"
  SMP.yield "\n"
  SMP.yield "enumeratedCountries :: [Word16]\n"
  SMP.yield "enumeratedCountries =\n"
  r <- flip mapStreamM (tagFirst s) $ \(isFirst,country) -> do
    if isFirst
      then SMP.yield "  [ "
      else SMP.yield "  , "
    yieldLazyText (TB.toLazyText (TBI.decimal (countryCode country)))
    SMP.yield "\n"
  SMP.yield "  ]\n"
  return r

identifierModule :: Monad m => Stream (Of Country) m r -> Stream (Of Text) m r
identifierModule s = do
  SMP.yield "module Country.Identifier where\n\n"
  SMP.yield "-- This module is autogenerated. Do not edit it by hand.\n\n"
  SMP.yield "import Country.Unsafe (Country(..))\n"
  SMP.yield "\n"
  flip mapStreamM s $ \country -> do
    let identifier = toIdentifier (countryName country)
    SMP.yield identifier
    SMP.yield " :: Country\n"
    SMP.yield identifier
    SMP.yield " = Country "
    yieldLazyText (TB.toLazyText (TBI.decimal (countryCode country)))
    SMP.yield "\n\n"

toIdentifier :: Text -> Text
toIdentifier t = case (T.uncons . T.filter isAlpha . T.toTitle) t of
  Nothing -> T.empty
  Just (b,bs) -> T.cons (toLower b) bs

englishEncoding :: Monad m => Stream (Of Country) m r -> Stream (Of Text) m r
englishEncoding s = do
  SMP.yield "-- This module is autogenerated. Do not edit it by hand.\n"
  SMP.yield "module Country.Unexposed.Encode.English\n"
  SMP.yield "  ( englishCountryNamesText\n"
  SMP.yield "  , countryNamePairs\n"
  SMP.yield "  ) where\n\n"
  SMP.yield "import Data.Primitive.Array\n"
  SMP.yield "import Data.Text (Text)\n"
  SMP.yield "import Control.Monad.ST (runST)\n"
  SMP.yield "import qualified Data.Text as T\n"
  SMP.yield "\n"
  SMP.yield "englishCountryNamesText :: Array Text\n"
  SMP.yield "englishCountryNamesText = runST $ do\n"
  SMP.yield "  m <- newArray 1000 unnamed\n"
  SMP.yield "  mapM_ (uncurry (writeArray m)) countryNamePairs\n"
  SMP.yield "  unsafeFreezeArray m\n"
  SMP.yield "{-# NOINLINE englishCountryNamesText #-}\n"
  SMP.yield "\n"
  SMP.yield "unnamed :: Text\n"
  SMP.yield "unnamed = T.pack \"Invalid Country\"\n"
  SMP.yield "{-# NOINLINE unnamed #-}\n"
  SMP.yield "\n"
  SMP.yield "countryNamePairs :: [(Int,Text)]\n"
  SMP.yield "countryNamePairs =\n"
  r <- flip mapStreamM (tagFirst s) $ \(isFirst,country) -> do
    if isFirst
      then SMP.yield "  [ ("
      else SMP.yield "  , ("
    yieldLazyText (TB.toLazyText (TBI.decimal (countryCode country)))
    SMP.yield ", T.pack \""
    SMP.yield (countryName country)
    SMP.yield "\")\n"
  SMP.yield "  ]\n"
  return r

yieldLazyText :: Monad m => LT.Text -> Stream (Of Text) m ()
yieldLazyText = mapM_ SMP.yield . LT.toChunks
    
tagFirst :: Monad m => Stream (Of a) m r -> Stream (Of (Bool,a)) m r
tagFirst = SMP.zip (SMP.yield True >> SMP.repeat False)

mapStreamM :: Monad m
  => (a -> Stream (Of b) m x)
  -> Stream (Of a) m r
  -> Stream (Of b) m r
mapStreamM f = SM.concats . SM.mapsM (\(a :> s) -> return (f a >> return s))

withCountries ::
     String -- ^ file name
  -> (forall r. Stream (Of Country) IO r -> Stream (Of Text) IO r) 
  -> IO ()
withCountries fn g = 
  withFile fn WriteMode $ \output ->
  withFile "countries.csv" ReadMode $ \input -> do
    m <- id
      $ BSM.hPut output
      $ BSM.fromChunks
      $ SMP.map encodeUtf8
      $ g
      $ S.decodeHeadedUtf8Csv siphon 
      $ BSM.toChunks
      $ BSM.fromHandle input
    case m of
      Nothing -> return ()
      Just err -> do
        hPutStrLn stderr (S.humanizeSiphonError err)
        fail "died"

data Country = Country
  { countryName :: Text
  , countryAlpha2 :: Text
  , countryAlpha3 :: Text
  , countryCode :: Int
  }

siphon :: Siphon Headed ByteString Country
siphon = Country
  <$> S.headed "name" decodeUtf8Maybe
  <*> S.headed "alpha-2" decodeUtf8Maybe
  <*> S.headed "alpha-3" decodeUtf8Maybe
  <*> S.headed "country-code" decodeInt

decodeUtf8Maybe :: ByteString -> Maybe Text
decodeUtf8Maybe = either (\_ -> Nothing) Just . decodeUtf8'

decodeInt :: ByteString -> Maybe Int
decodeInt b = do
  (a,bsRem) <- BC.readInt b
  if BC.null bsRem
    then Just a
    else Nothing
